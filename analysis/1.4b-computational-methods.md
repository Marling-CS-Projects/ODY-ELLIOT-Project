# 1.4b Computational Methods

## Thinking Abstractly and Visualization

Abstraction is the process of removing any unnecessary details from a problem so the problem is easier to solve as you can focus on the core details. Abstraction is important for game design as most problems are really complex but abstraction allows for simplification which, in turn, allows for the developer to solve the smaller problems and, eventually, solve the large problems they originally set out to solve.

Examples where I will use abstraction are:

* Dungeon generation algorithms
* Enemy behaviors
* Weapons

## Thinking Ahead

Thinking ahead in computer science means considering what may happen in the future and using that information to make smart decisions or design better systems. It's predicting what could go wrong or what might be needed ahead of time so that you can be prepared which leads to more efficient and user-friendly solutions.

Places where I may use this technique are in functions and performance optimization.

## Thinking Procedurally and Decomposition

Thinking procedurally and decomposition in computer science involve breaking down complex problems or tasks into smaller, manageable sub-tasks which have a clear sequence of steps to solve them.

I can use this to make each task into a reusable module so it is easier to design / code which will help make the program more organised and structured.

## Thinking Logically

Thinking logically in computer science involves identifying the decision the user makes whilst in a program and planning out the outcomes of their decision. It refers to rational thinking, identifying patterns, and analyzing problems.

I can use logical thinking to help solve complex problems and to anticipate a user's decisions to provide them with a satisfying outcome.

## Thinking Concurrently

Thinking concurrently refers to the ability to design systems that can handle multiple tasks running simulatneously. This is important in game design as there will often be multiple tasks running and interacting with each other (i.e. the player and an enemy) which will need to be handled by the program.
