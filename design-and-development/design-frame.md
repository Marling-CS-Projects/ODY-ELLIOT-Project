# 2.1 Design Frame

## Systems Diagram

<figure><img src="../.gitbook/assets/image (18) (1).png" alt=""><figcaption><p>Made using Google Slides</p></figcaption></figure>

The diagram above shows different sections of the game which I'll focus on making. I have put my [success criteria](../analysis/success-criteria.md) headers and split them into smaller sub-sections which I can choose to focus on throughout the development cycle (1 or 2 at a time). As I complete these sub-sections, the game will slowly piece together.

## Usability Features

Usability is a vital aspect of my game as I want my game to be accessible to as many people as possible. To create the best possible user experience there are 5 key points which I will use while developing my project.

These are:

### Effective

Effective usability is when the user completes a target/goal with both completeness and accuracy. In order to achieve this, I will let the player know what their goal is via the "how to play" button in both the [Main Menu](../analysis/features-of-the-proposed-solution.md#main-menu) and the [Pause Menu](../analysis/features-of-the-proposed-solution.md#pause-menu). As well as that, the dungeon will be quite linear to the player will be naturally drawn to the goal.

#### Aims

* Create an intuitive "How-To-Play" screen.
* Create a linear dungeon generation algorithm to naturally draw the player to the goal.

### Efficiency

Efficiency refers to the speed and accuracy a user can complete a goal. To make an efficient game I will create a menu system which is intuitive and easy to navigate as well as an easy [control scheme](../analysis/features-of-the-proposed-solution.md#controls).

#### Aims

* Create a menu system that is intuitive and easy to navigate.
* Create an easy control scheme.

### Engaging

Engagement is arguably the most important usability feature as it requires the solution to be engaging for the player while playing. To achieve this, I will create a procedural algorithm for each level as well as randomise enemies and weapon drops (from chests) in order to create a unique experience for each run which will help engage the player for a long time. As well as that, the[ pixel artwork](../analysis/features-of-the-proposed-solution.md#character) will also help add to user engagement.

#### Aims

* Create a procedural dungeon generation algorithm.
* Random enemies and weapon spawning.
* Pixel art for the game's sprites.

### Error Tolerant

The game must have as few errors as possible and, if an error occurs, it should be corrected by the solution. To do this, I will write code to manage a variety of scenarios and keep testing the game (trying to break it) to prevent it from crashing or breaking the game when someone is playing it.

#### Aims

* The game doesn't crash.
* The game does not contain any bugs that damage the user experience (e.g. going out of bounds)

### Easy To Learn

The game should be intuitive and not over-complicated as players often get frustrated when the game isn't responding to what they want to do. I will make the controls similar to other games so players can easily pick them up if they've played similar games. The controls also will be simple so new gamers can quickly learn how to play the game.

The "how to play" screen will also help players understand the [controls](../analysis/features-of-the-proposed-solution.md#controls).

#### Aims

* Create a "How-To-Play" screen.
* Create intuitive controls.
